#!/usr/bin/env python3

"""
This script runs the "tracr" CLI, which is powered by the API that lives in 
the "api" folder on this repo.

For a cleaner experience, add this directory to your PATH, which will allow
you to run the CLI from anywhere, and without preceding the command with
the word "python".
"""

import argparse
import socket
import sys
from rich.console import Console
from rich.table import Table
from getmac import get_mac_address
from pathlib import Path
from collections import defaultdict

import api.experiments as experiments
from api.config_mgr import Configs, ControllerConfigs, DeviceConfigs
from api.network import LAN, Device


# path to this file's location
project_root = Path(__file__).parent.absolute()

# path to console text files
textfiles = project_root / "setup" / "console_text"

# The config manager will be treated like a singleton, so it is intantiated
# here and initialized in the main function.
configs = None


# trivial function to be concise
def get_text(textfile: Path) -> str:
    with open(textfile, "r") as file:
        text = file.read()
    return text


# CLI is split up into submodules responsible for different operations, so
# there are lots of arguments that can be used, each with their own option
# flags and arguments. This is all organized using argparse, which reads
# the arguments and options and passes them to the appropriate function.

##############################################################################
##################### DEVICE SUBMODULE FUNCTIONS #############################
##############################################################################


def device_ls(args):
    """
    Shows the user a list of devices filtered by the given flags.

    Called by the "tracr device ls [-options]" command.

    Parameters:
    -----------
    args: argparse.Namespace
        The arguments and options passed to the CLI.
        "known": bool
            A flag to show only known devices.
        "unknown": bool
            A flag to show only unknown devices.
        "listening": bool
            A flag to show only devices that are listening for connections.
        "ready": bool
            A flag to show only devices that are ready to be used.
    """
    # explicitly set the flags to False if they are not set
    known = bool(args.known)
    unknown = bool(args.unknown)
    listening = bool(args.listening)
    ready = bool(args.ready)

    # if for some reason -ku or -ru is set, the correct output is none
    want_none = (known and unknown) or (ready and unknown)
    if want_none:
        print("No devices matching criteria")
        return

    def tag_status(devlist: list, tag: str) -> list:
        """A little helper function for adding a tag to each device in a list"""
        for dev in devlist:
            dev["status"] = tag

    # if no flags are set, then all devices should be shown
    want_all = not (known or unknown or listening or ready)

    # if -k or -u is set, we will need a list of known devices
    if known or unknown or want_all:
        known_devices = configs.controller.get_known_devices()
        tag_status(known_devices, "known")

    # if -u, -r, or -l is set, we will need to know which devices are responsive
    if unknown or listening or ready or want_all:
        responsive_device_ips = LAN().get_responsive_hosts()
        listening_devices = [
            Device().fetch_data(last_ip=ip) for ip in responsive_device_ips
        ]
        tag_status(listening_devices, "listening")
        # if -u is set, we will need a list of listening devices that are not known
        if unknown or want_all:
            known_macs = configs.controller.get_known_macs()
            unknown_devices = [
                device.copy()
                for device in listening_devices
                if device.get("mac_address") not in known_macs
            ]
            tag_status(unknown_devices, "unknown")

    # if -r is set, we will need to see which of the listening devices are ready
    if ready or want_all:
        ready_devices = [dev for dev in listening_devices if Device().is_ready(dev)]
        tag_status(ready_devices, "ready")

    k = known_devices or None
    u = unknown_devices or None
    l = listening_devices or None
    r = ready_devices or None

    dev_groups = [group for group in (k, u, l, r) if group is not None]

    def merge_dicts(*args, unique=None, combine=None):
        # Combine all the list-of-dicts into a single list-of-dicts
        merged = [item for sublist in args for item in sublist]

        # Find the union of all the keys
        all_keys = set().union(*[d.keys() for d in merged])

        # Add missing keys with an empty string value
        for d in merged:
            for key in all_keys:
                d.setdefault(key, "")

        # combine dicts describing the same device
        if unique:
            best_identifier, unique_count = None, 0
            for identifier in unique:
                if identifier in all_keys:
                    uc = len(set([d.get(identifier, None) for d in merged]))
                    if uc > unique_count:
                        best_identifier, unique_count = identifier, uc
            unique = best_identifier

            cleaned_list = []
            unique_vals = set([d[unique] for d in merged])
            for val in unique_vals:
                dicts_with_val = [d for d in merged if d[unique] == val]
                if len(dicts_with_val) > 1:
                    combo_dict = {}
                    for key in all_keys:
                        try:
                            all_vals = list(
                                set(
                                    [
                                        str(d[key])
                                        for d in dicts_with_val
                                        if d[key] != ""
                                    ]
                                )
                            )
                        except TypeError:
                            # TODO: figure out what to do with nested dict values
                            continue
                        if combine and key == combine:
                            combo_dict[key] = ", ".join(sorted(all_vals))
                        else:
                            # TODO: throw an error if there are multiple values for a non-combine key
                            combo_dict[key] = ", ".join(sorted(all_vals))
                    cleaned_list.append(combo_dict)
                else:
                    cleaned_list.append(dicts_with_val[0])

        return cleaned_list, list(all_keys)

    device_list, fields = merge_dicts(
        *dev_groups, unique=("uuid", "last_ip", "mac_address"), combine="status"
    )

    def custom_sort_key(item):
        """A custom sort key for the table, so that the columns are in a somewhat specific order"""
        mapping = {
            "uuid": 0,
            "status": 1,
            "nickname": 2,
            "last_ip": 3,
            "static_ip": 4,
        }
        if item in mapping:
            return (mapping[item],)
        else:
            # if it's not one of the special ones, use 5 as base for alphabetical order
            return 5, item

    fields = sorted(fields, key=custom_sort_key)
    rows = [[device.get(field) for field in fields] for device in device_list]

    table = Table(
        title=f"{len(device_list)} DEVICE{'S' if len(device_list) > 1 else ''} FOUND"
    )

    for field in fields:
        # justify, style, no_wrap
        j, s, nw = "left", "white", True
        if "mac" in field or "ip" in field:
            j = "center"
        if "status" in field:
            s = "cyan"
        if "description" in field:
            nw = False
        table.add_column(field, justify=j, style=s, no_wrap=nw)

    for row in rows:
        table.add_row(*row)

    console = Console()
    console.print(table)
    return


def device_refresh(args):
    """
    Updates known device information in the controller's local config file using the
    current network state.

    Called by the "tracr device refresh [-options]" command.

    Parameters
    ----------
    args : argparse.Namespace
        The parsed arguments from the command line
        'silent' : bool
            If True, the function will not print anything to the console
        'remote_device' : bool
            If True, the function will also update the remote device's config file
    """
    known_devices = configs.controller.get_known_devices()

    if not known_devices:
        print("No known devices to refresh")
        return

    kd_instances = [
        Device().create_from_dict(dev, auto_update=True) for dev in known_devices
    ]

    updated_devices = [dev.as_dict() for dev in kd_instances]

    def get_diffs(old: dict, new: dict, instance: Device) -> dict:
        """
        Returns a device and dict containing the differences between the old and new dicts
        """
        for key in set().union(old.keys(), new.keys()):
            if key not in old:
                old[key] = "none"
            if key not in new:
                new[key] = ""
        return (
            instance,
            {
                key: (old[key], new[key])
                for key in old.keys()
                if str(old[key]) != str(new[key])
            },
        )

    diffs = [
        get_diffs(old, new, dev)
        for old, new, dev in zip(known_devices, updated_devices, kd_instances)
    ]

    for dev, diff in diffs:
        for key, (old, new) in diff.items():
            if not isinstance(new, str):
                new = str(new)
            configs.controller.edit_known_device(
                ("mac_address", dev.get_mac_address()), (key, new)
            )
            if not args.silent:
                print(
                    f"CHANGED LOCAL CONFIGS - {dev.get_shortname()} {key}: {old} -> {new}"
                )

        if args.remote_file:
            with dev.open_ssh_client() as client:
                for key, (old, new) in diff.items():
                    configs.device.edit_config_item(client, key, new)
                    if not args.silent:
                        print(
                            f"CHANGED REMOTE CONFIGS - {dev.get_shortname()} {key}: {old} -> {new}"
                        )


def device_add(args):
    if args.wizard:
        pass
    if args.host:
        pass
    if args.user:
        pass
    if args.pw:
        pass
    if args.keys:
        pass
    if args.nickname:
        pass
    if args.description:
        pass


def setup_controller(args):
    reset = bool(args.reset)
    if args.overwrite:
        overwrites = {
            param: value
            for param, value in [param.split("=") for param in args.overwrite]
        }
    else:
        overwrites = False

    if reset and ControllerConfigs().config_file_exists_locally():
        confirm = input("Are you sure you want to reset the controller? [y/N] ")
        if not confirm.lower().startswith("y"):
            return
        ControllerConfigs().erase_local_config_file()
    new_configs = ControllerConfigs(make_new_config_file=True)

    if overwrites:
        for param, value in overwrites.items():
            new_configs.edit_config_item(param, value, category="controller")


def setup_device(args):
    # TODO: define setup device function
    pass


def setup_experiment(args):
    # TODO: define setup experiment function
    pass


def network(args):
    if args.d:
        print(f"Status for host: {args.d}")
    elif args.e:
        print(f"Status for name: {args.e}")
    else:
        print("Running network")


def run(args):
    if args.e:
        print(f"Running with name: {args.e}")
    else:
        print("Running")


def setup(args):
    if args.d:
        print(f"Setup for host: {args.d}")
    elif args.e:
        print(f"Setup for name: {args.e}")
    else:
        print("Running setup")


def main():
    parser = argparse.ArgumentParser(
        description=get_text(textfiles / "tracr_description.txt"),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=get_text(textfiles / "about_tracr.txt"),
    )
    subparsers = parser.add_subparsers(title="SUBMODULES")

    # parser for "device"
    parser_device = subparsers.add_parser(
        "device", help="Submodule for local device setup and configuration"
    )
    # add sub-sub parsers for the device module
    device_subparsers = parser_device.add_subparsers(title="DEVICE MODULE COMMANDS")
    parser_device_ls = device_subparsers.add_parser("ls", help="List devices")
    parser_device_ls.add_argument(
        "-k",
        "--known",
        action="store_true",
        help="only show known devices",
        dest="known",
    )
    parser_device_ls.add_argument(
        "-u",
        "--unknown",
        action="store_true",
        help="only show unknown devices",
        dest="unknown",
    )
    parser_device_ls.add_argument(
        "-l",
        "--listening",
        action="store_true",
        help="only show devices listening on port 22",
        dest="listening",
    )
    parser_device_ls.add_argument(
        "-r",
        "--ready",
        action="store_true",
        help="only show devices ready to run experiments",
        dest="ready",
    )
    parser_device_ls.set_defaults(func=device_ls)

    parser_device_refresh = device_subparsers.add_parser(
        "refresh", help="refresh known device information"
    )
    parser_device_refresh.add_argument(
        "-s",
        "--silent",
        action="store_true",
        help="do not print any output",
        dest="silent",
    )
    parser_device_refresh.add_argument(
        "-r",
        "--remote",
        help="update remote device config files",
        action="store_true",
        dest="remote_file",
    )
    parser_device_refresh.set_defaults(func=device_refresh)

    parser_device_add = device_subparsers.add_parser(
        "add", help="add new devices and configure them for experiments"
    )
    parser_device_add.add_argument(
        "-w",
        "--wizard",
        action="store_true",
        help="use a wizard to help with adding the new device",
        dest="wizard",
    )
    parser_device_add.add_argument(
        "-a",
        "--host",
        help="specify the hostname or IP address of the device to add",
        nargs=1,
        dest="host",
    )
    parser_device_add.add_argument(
        "-u",
        "--user",
        help="specify the username to connect with via SSH",
        nargs=1,
        dest="user",
    )
    parser_device_add.add_argument(
        "-p",
        "--pass",
        help="specify the password for SSH connections to the device",
        nargs=1,
        dest="pw",
    )
    parser_device_add.add_argument(
        "-k",
        "--keys",
        help="specify the public and private keys, separated by a space",
        nargs=2,
        dest="keys",
    )
    parser_device_add.add_argument(
        "-n",
        "--nickname",
        help="assign a nickname to the device",
        nargs=1,
        dest="nickname",
    )
    parser_device_add.add_argument(
        "-d",
        "--description",
        help="give a description to the device",
        nargs=1,
        dest="description",
    )
    parser_device_add.set_defaults(func=device_add)

    # Parser for "experiment"
    parser_experiment = subparsers.add_parser(
        "experiment", help="Submodule for managing experiments"
    )
    # Add sub-sub parsers for the experiment module
    exp_subparsers = parser_experiment.add_subparsers(help="experiment submodule help")
    parser_experiment_ls = exp_subparsers.add_parser(
        "ls", help="list experiments and experiment data"
    )
    parser_experiment_ls.add_argument(
        "-n",
        "--name",
        help="list the experiment names",
        action="store_true",
        dest="name",
    )
    parser_experiment_ls.add_argument(
        "-l",
        "--last-run",
        help="list the last time each experiment was run",
        action="store_true",
        dest="last_run",
    )
    parser_experiment_ls.add_argument(
        "-s",
        "--settings",
        help="list the settings for each experiment",
        action="store_true",
        dest="settings",
    )
    parser_experiment_run = exp_subparsers.add_parser("run", help="run an experiment")
    parser_experiment_run.add_argument(
        "name", nargs=1, help="the name of the experiment to be run"
    )
    parser_experiment_run.add_argument(
        "-o",
        "--output",
        help="specify a location for performance logging output",
        nargs=1,
        dest="output",
    )

    # Parser for 'setup'
    parser_setup = subparsers.add_parser("setup", help="Submodule for initial setup")

    # Add sub-sub parsers for the setup module
    setup_subparsers = parser_setup.add_subparsers(title="SETUP MODULE COMMANDS")
    parser_setup_controller = setup_subparsers.add_parser(
        "controller", help="Set up the controller"
    )
    parser_setup_controller.add_argument(
        "-r",
        "--reset",
        action="store_true",
        dest="reset",
        help="reset the controller configuration",
    )
    parser_setup_controller.add_argument(
        "-o",
        "--overwrite",
        nargs="+",
        dest="overwrite",
        help="controllerParam=overwriteValue",
    )
    parser_setup_controller.set_defaults(func=setup_controller)

    parser_setup_device = setup_subparsers.add_parser("device", help="Set up a device")
    # TODO: add arguments for device setup
    parser_setup_device.set_defaults(func=setup_device)

    parser_setup_experiment = setup_subparsers.add_parser(
        "experiment", help="Set up an experiment"
    )
    # TODO: add arguments for experiment setup
    parser_setup_experiment.set_defaults(func=setup_experiment)

    args = parser.parse_args()
    if "func" in args:
        global configs
        if "setup_controller" not in args.func.__name__:
            # initialize the config manager as a global singleton
            try:
                configs = Configs(
                    controller_config=ControllerConfigs(), device_config=DeviceConfigs()
                )
            except FileNotFoundError as e:
                print(
                    e,
                    "This machine may not have been set up as a controller yet.",
                    "Run 'tracr setup --help' for setup commands.",
                    sep="\n",
                )
                sys.exit(1)
        args.func(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
