#!/usr/bin/env python3

"""
This script runs the "tracr" CLI, which is powered by the API that lives in 
the "api" folder on this repo.

For a cleaner experience, add this directory to your PATH, which will allow
you to run the CLI from anywhere, and without preceding the command with
the word "python".
"""

import argparse
import json
import socket
import os
import shutil
import sys
from rich.panel import Panel
from rich.columns import Columns
from rich.console import Console
from rich.table import Table
from getmac import get_mac_address
from pathlib import Path
from collections import defaultdict

from api.experiments import Experiment
from api.config_mgr import Configs, ControllerConfigs, DeviceConfigs
from api.network import LAN, Device, Controller


# path to this file's location
project_root = Path(__file__).parent.absolute()

# path to console text files
textfiles = project_root / "setup" / "console_text"

# The config manager will be treated like a singleton, so it is intantiated
# here and initialized in the main function.
controller = None


# trivial function to be concise
def get_text(textfile: Path) -> str:
    with open(textfile, "r") as file:
        text = file.read()
    return text


# CLI is split up into submodules responsible for different operations, so
# there are lots of arguments that can be used, each with their own option
# flags and arguments. This is all organized using argparse, which reads
# the arguments and options and passes them to the appropriate function.

##############################################################################
##################### DEVICE SUBMODULE FUNCTIONS #############################
##############################################################################


def device_ls(args):
    """
    Shows the user a list of devices filtered by the given flags.

    Called by the "tracr device ls [-options]" command.

    Parameters:
    -----------
    args: argparse.Namespace
        The arguments and options passed to the CLI.
        "known": bool
            A flag to show only known devices.
        "unknown": bool
            A flag to show only unknown devices.
        "listening": bool
            A flag to show only devices that are listening for connections.
        "ready": bool
            A flag to show only devices that are ready to be used.
    """

    # if for some reason -ku or -ru is set, the correct output is none
    if (args.known and args.unknown) or (args.ready and args.unknown):
        print("\nNo devices matching criteria\n")
        return

    # if no flags are set, show all devices
    want_all = not (args.known or args.unknown or args.ready or args.listening)

    # fetch all required devices at once
    known_devices = (
        controller.config.get_known_devices()
        if args.known or args.unknown or want_all
        else []
    )
    known_devices = [Device(controller, **d) for d in known_devices]

    fetched_devices = (
        [Device.fetch_data(last_ip=ip) for ip in LAN.get_responsive_hosts()]
        if args.unknown or args.listening or args.ready or want_all
        else []
    )
    for d in fetched_devices:
        d["auto_update"] = True
    listening_devices = [Device(controller, **d) for d in fetched_devices]

    # derive the unknown and ready devices
    known_macs = set(controller.config.get_known_macs())
    unknown_devices = [
        device for device in listening_devices if device.uuid not in known_macs
    ]
    ready_devices = [device for device in listening_devices if device.is_ready()]

    device_types = {
        "known": known_devices,
        "unknown": unknown_devices,
        "listening": listening_devices,
        "ready": ready_devices,
    }

    # All devices to be displayed
    all_devices = [device for devices in device_types.values() for device in devices]

    # Combine instances by uuid
    combined_instances = {}
    for instance in all_devices:
        if instance.uuid in combined_instances:
            combined_instances[instance.uuid] = combined_instances[
                instance.uuid
            ].absorb(instance)
        else:
            combined_instances[instance.uuid] = instance

    # Assign status to all devices
    for device in combined_instances.values():
        device.status = ", ".join(
            tag for tag, devices in device_types.items() if device in devices
        )

    console = Console()
    panels = []

    fields = list(Device.get_default_attribs())
    fields.insert(1, "status")

    for device in combined_instances.values():
        device_info = "\n".join([f"{field}: {device._get(field)}" for field in fields])
        panel = Panel(device_info)
        panels.append(panel)

    console.print(Columns(panels))
    return


def device_refresh(args):
    """
    Updates known device information in the controller's local config file using the
    current network state.

    Called by the "tracr device refresh [-options]" command.

    Parameters
    ----------
    args : argparse.Namespace
        The parsed arguments from the command line
        'silent' : bool
            If True, the function will not print anything to the console
        'remote_device' : bool
            If True, the function will also update the remote device's config file
    """
    known_devices = controller.config.get_known_devices()

    if not known_devices:
        print("No known devices to refresh")
        return

    kd_instances = [Device(**dev, auto_update=True) for dev in known_devices]

    updated_devices = [dev.as_dict() for dev in kd_instances]

    def get_diffs(old: dict, new: dict, instance: Device) -> dict:
        """
        Returns a device and dict containing the differences between the old and new dicts
        """
        for key in set().union(old.keys(), new.keys()):
            if key not in old:
                old[key] = "none"
            if key not in new:
                new[key] = ""
        return (
            instance,
            {
                key: (old[key], new[key])
                for key in old.keys()
                if str(old[key]) != str(new[key])
            },
        )

    diffs = [
        get_diffs(old, new, dev)
        for old, new, dev in zip(known_devices, updated_devices, kd_instances)
    ]

    for dev, diff in diffs:
        for key, (old, new) in diff.items():
            if not isinstance(new, str):
                new = str(new)
            controller.config.edit_known_device(
                ("mac_address", dev.get_mac_address()), (key, new)
            )
            if not args.silent:
                print(
                    f"CHANGED LOCAL CONFIGS - {dev.get_shortname()} {key}: {old} -> {new}"
                )

        if args.remote_file:
            with dev.open_ssh_client() as client:
                for key, (old, new) in diff.items():
                    controller.device.edit_config_item(client, key, new)
                    if not args.silent:
                        print(
                            f"CHANGED REMOTE CONFIGS - {dev.get_shortname()} {key}: {old} -> {new}"
                        )


def device_add(args):
    if args.wizard:
        pass
    if args.host:
        pass
    if args.user:
        pass
    if args.pw:
        pass
    if args.keys:
        pass
    if args.nickname:
        pass
    if args.description:
        pass


##############################################################################
#################### EXPERIMENT SUBMODULE FUNCTIONS ##########################
##############################################################################


def experiment_add(args):
    """
    Adds a new experiment to the controller's local system by setting up
    a 'blank slate' directory inside of TestCases.
    """
    experiment_name = args.name[0]
    success, message = Experiment.add_new(experiment_name)

    print(f"\n{message}\n")

    if not success:
        print(
            "Use 'tracr experiment add --help' for more information on how to use this command."
        )
    return


##############################################################################
######################### SETUP SUBMODULE FUNCTIONS ##########################
##############################################################################


def setup_controller(args):
    reset = bool(args.reset)
    if args.overwrite:
        overwrites = {
            param: value
            for param, value in [param.split("=") for param in args.overwrite]
        }
    else:
        overwrites = False

    if reset and ControllerConfigs().config_file_exists_locally():
        confirm = input("Are you sure you want to reset the controller? [y/N] ")
        if not confirm.lower().startswith("y"):
            return
        ControllerConfigs().erase_local_config_file()
    new_controller = ControllerConfigs(make_new_config_file=True)

    if overwrites:
        for param, value in overwrites.items():
            new_controller.edit_config_item(param, value, category="controller")


def setup_device(args):
    # TODO: define setup device function
    pass


def setup_experiment(args):
    # TODO: define setup experiment function
    pass


def network(args):
    if args.d:
        print(f"Status for host: {args.d}")
    elif args.e:
        print(f"Status for name: {args.e}")
    else:
        print("Running network")


def run(args):
    if args.e:
        print(f"Running with name: {args.e}")
    else:
        print("Running")


def setup(args):
    if args.d:
        print(f"Setup for host: {args.d}")
    elif args.e:
        print(f"Setup for name: {args.e}")
    else:
        print("Running setup")


def main():
    parser = argparse.ArgumentParser(
        description=get_text(textfiles / "tracr_description.txt"),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version=get_text(textfiles / "about_tracr.txt"),
    )
    subparsers = parser.add_subparsers(title="SUBMODULES")

    # parser for "device"
    parser_device = subparsers.add_parser(
        "device", help="Local device setup and configuration"
    )
    # add sub-sub parsers for the device module
    device_subparsers = parser_device.add_subparsers(title="DEVICE MODULE COMMANDS")
    parser_device_ls = device_subparsers.add_parser("ls", help="List devices")
    parser_device_ls.add_argument(
        "-k",
        "--known",
        action="store_true",
        help="only show known devices",
        dest="known",
    )
    parser_device_ls.add_argument(
        "-u",
        "--unknown",
        action="store_true",
        help="only show unknown devices",
        dest="unknown",
    )
    parser_device_ls.add_argument(
        "-l",
        "--listening",
        action="store_true",
        help="only show devices listening on port 22",
        dest="listening",
    )
    parser_device_ls.add_argument(
        "-r",
        "--ready",
        action="store_true",
        help="only show devices ready to run experiments",
        dest="ready",
    )
    parser_device_ls.set_defaults(func=device_ls)

    parser_device_refresh = device_subparsers.add_parser(
        "refresh", help="refresh known device information"
    )
    parser_device_refresh.add_argument(
        "-s",
        "--silent",
        action="store_true",
        help="do not print any output",
        dest="silent",
    )
    parser_device_refresh.add_argument(
        "-r",
        "--remote",
        help="update remote device config files",
        action="store_true",
        dest="remote_file",
    )
    parser_device_refresh.set_defaults(func=device_refresh)

    parser_device_add = device_subparsers.add_parser(
        "add", help="add new devices and configure them for experiments"
    )
    parser_device_add.add_argument(
        "-w",
        "--wizard",
        action="store_true",
        help="use a wizard to help with adding the new device",
        dest="wizard",
    )
    parser_device_add.add_argument(
        "-a",
        "--host",
        help="specify the hostname or IP address of the device to add",
        nargs=1,
        dest="host",
    )
    parser_device_add.add_argument(
        "-u",
        "--user",
        help="specify the username to connect with via SSH",
        nargs=1,
        dest="user",
    )
    parser_device_add.add_argument(
        "-p",
        "--pass",
        help="specify the password for SSH connections to the device",
        nargs=1,
        dest="pw",
    )
    parser_device_add.add_argument(
        "-k",
        "--keys",
        help="specify the public and private keys, separated by a space",
        nargs=2,
        dest="keys",
    )
    parser_device_add.add_argument(
        "-n",
        "--nickname",
        help="assign a nickname to the device",
        nargs=1,
        dest="nickname",
    )
    parser_device_add.add_argument(
        "-d",
        "--description",
        help="give a description to the device",
        nargs=1,
        dest="description",
    )
    parser_device_add.set_defaults(func=device_add)

    # Parser for "experiment"
    parser_experiment = subparsers.add_parser(
        "experiment", help="Manage and run experiments"
    )
    # Add sub-sub parsers for the experiment module
    exp_subparsers = parser_experiment.add_subparsers(help="experiment submodule help")
    parser_experiment_ls = exp_subparsers.add_parser(
        "ls", help="list experiments and experiment data"
    )
    parser_experiment_ls.add_argument(
        "-n",
        "--name",
        help="list the experiment names",
        action="store_true",
        dest="name",
    )
    parser_experiment_ls.add_argument(
        "-l",
        "--last-run",
        help="list the last time each experiment was run",
        action="store_true",
        dest="last_run",
    )
    parser_experiment_ls.add_argument(
        "-s",
        "--settings",
        help="list the settings for each experiment",
        action="store_true",
        dest="settings",
    )
    parser_experiment_run = exp_subparsers.add_parser("run", help="run an experiment")
    parser_experiment_run.add_argument(
        "name", nargs=1, help="the name of the experiment to be run"
    )
    parser_experiment_run.add_argument(
        "-l",
        "--local",
        help="run the experiment locally using simulated devices",
        action="store_true",
        dest="local",
    )
    parser_experiment_run.add_argument(
        "-o",
        "--output",
        help="specify a location for performance logging output",
        nargs=1,
        dest="output",
    )

    parser_experiment_add = exp_subparsers.add_parser(
        "add", help="add a new experiment"
    )
    parser_experiment_add.add_argument(
        "name", nargs=1, help="the name of the experiment to create"
    )
    parser_experiment_add.set_defaults(func=experiment_add)

    # Parser for 'setup'
    parser_setup = subparsers.add_parser("setup", help="Guided initial setup")

    # Add sub-sub parsers for the setup module
    setup_subparsers = parser_setup.add_subparsers(title="SETUP MODULE COMMANDS")
    parser_setup_controller = setup_subparsers.add_parser(
        "controller", help="Set up the controller"
    )
    parser_setup_controller.add_argument(
        "-r",
        "--reset",
        action="store_true",
        dest="reset",
        help="reset the controller configuration",
    )
    parser_setup_controller.add_argument(
        "-o",
        "--overwrite",
        nargs="+",
        dest="overwrite",
        help="controllerParam=overwriteValue",
    )
    parser_setup_controller.set_defaults(func=setup_controller)

    parser_setup_device = setup_subparsers.add_parser("device", help="Set up a device")
    # TODO: add arguments for device setup
    parser_setup_device.set_defaults(func=setup_device)

    parser_setup_experiment = setup_subparsers.add_parser(
        "experiment", help="Set up an experiment"
    )
    # TODO: add arguments for experiment setup
    parser_setup_experiment.set_defaults(func=setup_experiment)

    args = parser.parse_args()
    if "func" in args:
        global controller
        if "setup_controller" not in args.func.__name__:
            # initialize the config manager as a global singleton
            try:
                controller = Controller()
            except FileNotFoundError as e:
                print(
                    e,
                    "This machine may not have been set up as a controller yet.",
                    "Run 'tracr setup --help' for setup commands.",
                    sep="\n",
                )
                sys.exit(1)
        args.func(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
